# Документация TUI

Библиотека предоставляет возможность пользователю возможность создавать области блоков на карте,
которые работают по принципу обычного пользовательского интерфейса: на эту область можно нажимать
с помощью the grand design (великий план) и что-то может происходить. Например, можно поставить
кнопку, которая по нажатию будет выводить в чат что-то. И в принципе разработчик ограничен лишь своей
фантазией в том, что можно создать на пользовательском интерфейсе. Примером может быть настольная
игра сапер, на которую ушло 314 строк кода (включая логику самой игры):

![](minesweeper.png)

Эти и некоторые другие примеры игр вы можете посмотреть в измерении games на серврере terraria-servers.ru:7777.

## Основы интерфейса

Каждый элемент, будь то кнопка, надпись, поле ввода, слайдер или что-то еще, является объектом класса,
наследуемого от базового класса VisualObject. Например, слайдер - это класс Slider, наследующийся сразу
от VisualObject. А кнопка - это класс Button, наследующийся от класса Label, который тоже в свою очередь
наследуется от VisualObject. Любой виджет, работающий в этой библиотеке обязан наследоваться от VisualObject.
Весь интерфейс сам по себе представляет из себя набор деревьев, каждая вершина которого - VisualObject
или объект класса, наследующегося от VisualObject. При это корень дерева - это всегда объект класса
RootVisualObject или класса, наследующегося от RootVisualObject (на примере - Panel)

![](VisualObjectTree.png)

Дочерние элементы объекта VisualObject находятся в поле закрытом поле Child (List<VisualObject>).
Родительсткая вершина хранится в поле Parent (VisualObject).
Корень дерева доступен по геттеру Root (RootVisualObject). Учтите, что получить доступ к этому полю
можно только после того, как будет вызван Update всего дерева. Чтобы получить корень дерева
до вызова Update(), воспользуйтесь методом GetRoot().
Добавить дочерний элемент можно несколькими способами, например - вызвав функцию Add:
**VisualObject *Add*(VisualObject newChild)**

## Базовые операции над VisualObject

Есть несколько важных операций, которые можно применять к объектам VisualObject:
1. **Update()**
Рекурсивная функция, обновляющая каждый из объектов поддерева (устанавливает нужные значения в
нужные поля, рассчитывает позицию относительных элементов, ...)
2. **Apply()**
Рекурсивная функция, отрисовывающая объект на карте (изменение блоков карты в соостветствии
со стилем отображения элемента)
3. **Draw()**
Отправка отрисованного (хотя не обязательно) объекта игрокам с помощью SendSection или SendTileSquare

Эти три операции обычно идут в указанном порядке и делают примерно следующее:
Вызов Update вычисляет значение поля Root, потом вычисляет позиции дочерних элементов и
запускает рекурсивно вызов Update у дочерних элементов.
Вызов Apply устанавливает во всей области объекта 155 стену (diamond gemspark wall),
затем рекурсивно вызывает Apply у дочерних элементов.
Вызов Draw отправляет секцию или SendTileSquare всем игрокам.

## Класс UI

Существует статичный класс UI, который представляет из себя список корней RootVisualObject
и обладает операциями, похожими на описанные выше для VisualObject:
Update, Apply, Draw
Эти функции сделают одноименный вызов ко всем корням. Таким образом, чтобы полностью обновить
и отрисовать все деревья пользовательского интерфейса, необходимо выполнить:
UI.Update();
UI.Apply();
UI.Draw();

Чтобы создать новое поддерево, необходимо вызвать один из методов класса UI:
1. RootVisualObject **CreateRoot**(string *name*, int *x*, int *y*, int *width*, int *height*, UIConfiguration *configuration* = null, UIStyle *style* = null, object *provider* = null)
2. Panel **CreatePanel**(string *name*, int *x*, int *y*, int *width*, int *height*, UIConfiguration *configuration* = null, UIStyle *style* = null, object *provider* = null)
2. Panel **CreatePanel**(string *name*, int *x*, int *y*, int *width*, int *height*, UIConfiguration *configuration* = null, UIStyle *style* = null, object *provider* = null)